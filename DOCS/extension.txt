P√°gina inicial
Docs
Chrome Extensions
Get started
Isso foi √∫til?

Extens√£o Hello World

bookmark_border
Aprenda o b√°sico do desenvolvimento de extens√µes do Chrome criando sua primeira extens√£o Hello World.

Vis√£o geral
Voc√™ vai criar um exemplo "Hello World", carregar a extens√£o localmente, localizar registros e conferir outras recomenda√ß√µes.

Hello World
Essa extens√£o vai mostrar "Hello Extensions" quando o usu√°rio clicar no √≠cone da barra de ferramentas da extens√£o.

Extens√£o Hello
Pop-up da extens√£o Hello
Comece criando um novo diret√≥rio para armazenar os arquivos de extens√£o. Se preferir, fa√ßa o download do c√≥digo-fonte completo no GitHub.

Em seguida, crie um novo arquivo nesse diret√≥rio chamado manifest.json. Esse arquivo JSON descreve os recursos e a configura√ß√£o da extens√£o. Por exemplo, a maioria dos arquivos de manifesto cont√©m uma chave "action" que declara a imagem que o Chrome precisa usar como √≠cone de a√ß√£o da extens√£o e a p√°gina HTML que ser√° mostrada em um pop-up quando o √≠cone de a√ß√£o da extens√£o for clicado.


{
  "name": "Hello Extensions",
  "description": "Base Level Extension",
  "version": "1.0",
  "manifest_version": 3,
  "action": {
    "default_popup": "hello.html",
    "default_icon": "hello_extensions.png"
  }
}
Fa√ßa o download do √≠cone no seu diret√≥rio e mude o nome dele para corresponder ao que est√° na chave "default_icon".

Para o pop-up, crie um arquivo chamado hello.html e adicione o seguinte c√≥digo:


<html>
  <body>
    <h1>Hello Extensions</h1>
  </body>
</html>
A extens√£o agora mostra um pop-up quando o √≠cone de a√ß√£o (√≠cone da barra de ferramentas) √© clicado. Para testar no Chrome, carregue-o localmente. Confira se todos os arquivos foram salvos.

Carregar uma extens√£o descompactada
Para carregar uma extens√£o descompactada no modo de desenvolvedor:

Acesse a p√°gina "Extens√µes" digitando chrome://extensions em uma nova guia. Os URLs chrome:// n√£o podem ser vinculados.
Como alternativa, clique no bot√£o de quebra-cabe√ßa do menu "Extens√µes" e selecione Gerenciar extens√µes na parte de baixo do menu.
Ou clique no menu do Chrome, passe o cursor sobre Mais ferramentas e selecione Extens√µes.
Ative o modo de desenvolvedor clicando no bot√£o ao lado de Modo de desenvolvedor.
Clique no bot√£o Carregar descompactado e selecione o diret√≥rio de extens√£o.
P√°gina &quot;Extens√µes&quot;
P√°gina de extens√µes (chrome://extensions)
Tcham! A extens√£o foi instalada. Se nenhum √≠cone de extens√£o for inclu√≠do no manifesto, um √≠cone gen√©rico ser√° criado para a extens√£o.

Fixar a extens√£o
Por padr√£o, quando voc√™ carrega a extens√£o localmente, ela aparece no menu de extens√µes (Quebra-cabe√ßa). Fixe a extens√£o na barra de ferramentas para acessar rapidamente durante o desenvolvimento.

Fixar a extens√£o
Fixar a extens√£o
Clique no √≠cone de a√ß√£o da extens√£o (√≠cone da barra de ferramentas). Um pop-up vai aparecer.

extens√£o hello world
Extens√£o Hello World
Recarregar a extens√£o
Volte ao c√≥digo e mude o nome da extens√£o para "Hello Extensions of the world!" no manifesto.


{
  "manifest_version": 3,
  "name": "Hello Extensions of the world!",
  ...
}
Depois de salvar o arquivo, para ver essa mudan√ßa no navegador, voc√™ tamb√©m precisa atualizar a extens√£o. Acesse a p√°gina "Extens√µes" e clique no √≠cone de atualiza√ß√£o ao lado do bot√£o ativado/desativado:

Recarregar uma extens√£o

Quando recriar a extens√£o
A tabela a seguir mostra quais componentes precisam ser recarregados para mostrar as mudan√ßas:

Componente da extens√£o	√â necess√°rio atualizar a extens√£o
O manifesto	Sim
Service worker	Sim
Scripts de conte√∫do	Sim (e a p√°gina de hospedagem)
O pop-up	N√£o
P√°gina de op√ß√µes	N√£o
Outras p√°ginas HTML da extens√£o	N√£o
Encontrar registros e erros do console
Registros do console
Durante o desenvolvimento, √© poss√≠vel depurar o c√≥digo acessando os registros do console do navegador. Nesse caso, vamos localizar os registros do pop-up. Comece adicionando uma tag de script a hello.html.


<html>
  <body>
    <h1>Hello Extensions</h1>
    <script src="popup.js"></script>
  </body>
</html>
Crie um arquivo popup.js e adicione o seguinte c√≥digo:


console.log("This is a popup!")
Para conferir essa mensagem registrada no console:

Abra o pop-up.
Clique com o bot√£o direito do mouse no pop-up.
Selecione Inspecionar.
Inspe√ß√£o do pop-up.
Inspe√ß√£o de um pop-up.
Nas DevTools, navegue at√© o painel Console.
Painel de c√≥digo das DevTools
Como inspecionar um pop-up
Registros de erro
Agora vamos interromper a extens√£o. Para fazer isso, remova a cita√ß√£o final em popup.js:


console.log("This is a popup!) // ‚ùå broken code
Acesse a p√°gina "Extens√µes" e abra o pop-up. O bot√£o Errors vai aparecer.

P√°gina de extens√µes com o bot√£o de erro

Clique no bot√£o Errors para saber mais sobre o erro:

Detalhes do erro da extens√£o

Para saber mais sobre como depurar o service worker, a p√°gina de op√ß√µes e os scripts de conte√∫do, consulte Como depurar extens√µes.

Estruturar um projeto de extens√£o
H√° muitas maneiras de estruturar um projeto de extens√£o. No entanto, o √∫nico pr√©-requisito √© colocar o arquivo manifest.json no diret√≥rio raiz da extens√£o, como no exemplo abaixo:

O conte√∫do de uma pasta de extens√£o: manifest.json, background.js, pasta de scripts, pasta de pop-ups e pasta de imagens.

Usar o TypeScript
Se voc√™ estiver desenvolvendo usando um editor de c√≥digo, use o pacote npm chrome-types para aproveitar o preenchimento autom√°tico da API Chrome. Esse pacote do npm √© atualizado automaticamente quando o c√≥digo-fonte do Chromium √© alterado.

Ponto-chave:atualize esse pacote npm com frequ√™ncia para que ele funcione com a vers√£o mais recente do Chromium.
üöÄ Tudo pronto para come√ßar a criar?
Escolha um dos tutoriais a seguir para come√ßar sua jornada de aprendizado.

Extens√£o	O que voc√™ vai aprender
Executar scripts em todas as p√°ginas	Para inserir um elemento em cada p√°gina automaticamente.
Injetar scripts na guia ativa	Para executar o c√≥digo na p√°gina atual depois de clicar na a√ß√£o da extens√£o.
Gerenciar guias	Para criar um pop-up que gerencie as guias do navegador.
Processar eventos com service workers	Como um worker de servi√ßo de extens√£o processa eventos.

P√°gina inicial
Docs
Chrome Extensions
Get started
Isso foi √∫til?

Executar scripts em todas as p√°ginas

bookmark_border
Crie sua primeira extens√£o que insere um novo elemento na p√°gina.

Vis√£o geral
Este tutorial cria uma extens√£o que adiciona o tempo de leitura esperado a qualquer extens√£o do Chrome e √† p√°gina de documenta√ß√£o da Chrome Web Store.

Extens√£o de tempo de leitura na p√°gina de boas-vindas da extens√£o
Extens√£o do tempo de leitura na p√°gina de boas-vindas da extens√£o.
Neste guia, vamos explicar os seguintes conceitos:

O manifesto da extens√£o.
Quais tamanhos de √≠cone uma extens√£o usa.
Como injetar c√≥digo em p√°ginas usando scripts de conte√∫do.
Como usar padr√µes de correspond√™ncia.
Permiss√µes de extens√£o.
Antes de come√ßar
Neste guia, presumimos que voc√™ tenha experi√™ncia b√°sica em desenvolvimento da Web. Recomendamos conferir o tutorial Hello World para uma introdu√ß√£o ao fluxo de trabalho de desenvolvimento de extens√µes.

Criar a extens√£o
Para come√ßar, crie um novo diret√≥rio chamado reading-time para armazenar os arquivos da extens√£o. Se preferir, fa√ßa o download do c√≥digo-fonte completo no GitHub.

Etapa 1: adicionar informa√ß√µes sobre a extens√£o
O arquivo JSON do manifesto √© o √∫nico obrigat√≥rio. Ela cont√©m informa√ß√µes importantes sobre a extens√£o. Crie um arquivo manifest.json na raiz do projeto e adicione o seguinte c√≥digo:


{
  "manifest_version": 3,
  "name": "Reading time",
  "version": "1.0",
  "description": "Add the reading time to Chrome Extension documentation articles"
}
Essas chaves cont√™m metadados b√°sicos da extens√£o. Eles controlam como a extens√£o aparece na p√°gina de extens√µes e, quando publicada, na Chrome Web Store. Para saber mais, confira as chaves "name", "version" e "description" na p√°gina de vis√£o geral do manifesto.

üí° Outros fatos sobre o manifesto de extens√£o

Ele precisa estar localizado na raiz do projeto.
As √∫nicas chaves obrigat√≥rias s√£o "manifest_version", "name" e "version".
Ele oferece suporte a coment√°rios (//) durante o desenvolvimento, mas eles precisam ser removidos antes de fazer upload do c√≥digo para a Chrome Web Store.
Etapa 2: fornecer os √≠cones
Por que voc√™ precisa de √≠cones? Embora os √≠cones sejam opcionais durante o desenvolvimento, eles s√£o necess√°rios se voc√™ planeja distribuir a extens√£o na Chrome Web Store. Elas tamb√©m aparecem em outros lugares, como a p√°gina "Gerenciamento de extens√µes".

Crie uma pasta images e coloque os √≠cones nela. Fa√ßa o download dos √≠cones no GitHub. Em seguida, adicione o c√≥digo destacado ao manifesto para declarar √≠cones:


{
  "icons": {
    "16": "images/icon-16.png",
    "32": "images/icon-32.png",
    "48": "images/icon-48.png",
    "128": "images/icon-128.png"
  }
}
Recomendamos o uso de arquivos PNG, mas outros formatos s√£o permitidos, exceto SVG.

üí° Onde esses √≠cones de tamanhos diferentes s√£o exibidos?

Tamanho do √≠cone	Uso do √≠cone
16x16	√çcone nas p√°ginas da extens√£o e no menu de contexto.
32x32	Os computadores Windows geralmente exigem esse tamanho.
48x48	√â exibido na p√°gina "Extens√µes".
128x128	√â exibido na instala√ß√£o e na Chrome Web Store.
Etapa 3: declarar o script de conte√∫do
As extens√µes podem executar scripts que leem e modificam o conte√∫do de uma p√°gina. Eles s√£o chamados de scripts de conte√∫do. Eles vivem em um mundo isolado, o que significa que podem fazer mudan√ßas no ambiente do JavaScript sem entrar em conflito com a p√°gina de destino ou outros scripts de conte√∫do de extens√µes.

Adicione o c√≥digo abaixo ao manifest.json para registrar um script de conte√∫do chamado content.js.


{
  "content_scripts": [
    {
      "js": ["scripts/content.js"],
      "matches": [
        "https://developer.chrome.com/docs/extensions/*",
        "https://developer.chrome.com/docs/webstore/*"
      ]
    }
  ]
}
O campo "matches" pode ter um ou mais padr√µes de correspond√™ncia. Eles permitem que o navegador identifique em quais sites injetar os scripts de conte√∫do. Os padr√µes de correspond√™ncia consistem em tr√™s partes: <scheme>://<host><path>. Eles podem conter caracteres *.

üí° Essa extens√£o mostra um aviso de permiss√£o?

Quando um usu√°rio instala uma extens√£o, o navegador informa o que ela pode fazer. Os scripts de conte√∫do solicitam permiss√£o para serem executados em sites que atendem aos crit√©rios do padr√£o de correspond√™ncia.

Neste exemplo, o usu√°rio vai receber o seguinte aviso de permiss√£o:

Aviso de permiss√£o que o usu√°rio vai receber ao instalar a extens√£o do Reading Time
Aviso de permiss√£o de tempo de leitura.
Para saber mais sobre as permiss√µes de extens√µes, consulte Declarar permiss√µes e avisar os usu√°rios.

Etapa 4: calcular e inserir o tempo de leitura
Os scripts de conte√∫do podem usar o modelo de objeto de documento (DOM) padr√£o para ler e mudar o conte√∫do de uma p√°gina. A extens√£o primeiro verifica se a p√°gina cont√©m o elemento <article>. Em seguida, ele vai contar todas as palavras dentro desse elemento e criar um par√°grafo que mostra o tempo total de leitura.

Crie um arquivo chamado content.js dentro de uma pasta chamada scripts e adicione o seguinte c√≥digo:


function renderReadingTime(article) {
  // If we weren't provided an article, we don't need to render anything.
  if (!article) {
    return;
  }

  const text = article.textContent;
  const wordMatchRegExp = /[^\s]+/g; // Regular expression
  const words = text.matchAll(wordMatchRegExp);
  // matchAll returns an iterator, convert to array to get word count
  const wordCount = [...words].length;
  const readingTime = Math.round(wordCount / 200);
  const badge = document.createElement("p");
  // Use the same styling as the publish information in an article's header
  badge.classList.add("color-secondary-text", "type--caption");
  badge.textContent = `‚è±Ô∏è ${readingTime} min read`;

  // Support for API reference docs
  const heading = article.querySelector("h1");
  // Support for article docs with date
  const date = article.querySelector("time")?.parentNode;

  (date ?? heading).insertAdjacentElement("afterend", badge);
}

renderReadingTime(document.querySelector("article"));
üí° JavaScript interessante usado neste c√≥digo

Express√µes regulares usadas para contar apenas as palavras dentro do elemento <article>.
insertAdjacentElement() usado para inserir o n√≥ de tempo de leitura ap√≥s o elemento.
A propriedade classList usada para adicionar nomes de classes CSS ao atributo de classe do elemento.
Vincula√ß√£o opcional usada para acessar uma propriedade de objeto que pode ser indefinida ou nula.
A coalesc√™ncia de nulos retorna <heading> se <date> for nulo ou indefinido.
Etapa 5: detectar mudan√ßas
Com o c√≥digo atual, se voc√™ alternar entre artigos usando a navega√ß√£o √† esquerda, o tempo de leitura n√£o ser√° adicionado ao novo artigo. Isso ocorre porque nosso site √© implementado como um aplicativo de p√°gina √∫nica (SPA) que realiza navega√ß√µes suaves usando a API History.

Para corrigir isso, podemos usar um MutationObserver para detectar mudan√ßas e adicionar o tempo de leitura a novos artigos.

Para fazer isso, adicione o seguinte √† parte de baixo de content.js:

Aviso: o uso de MutationObserver pode ter um custo de desempenho. Por isso, use-os com modera√ß√£o e observe apenas as mudan√ßas mais relevantes.

const observer = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    // If a new article was added.
    for (const node of mutation.addedNodes) {
      if (node instanceof Element && node.tagName === 'ARTICLE') {
        // Render the reading time for this particular article.
        renderReadingTime(node);
      }
    }
  }
});

// https://developer.chrome.com/ is a SPA (Single Page Application) so can
// update the address bar and render new content without reloading. Our content
// script won't be reinjected when this happens, so we need to watch for
// changes to the content.
observer.observe(document.querySelector('devsite-content'), {
  childList: true
});
Testar se funciona
Verifique se a estrutura de arquivos do projeto tem a seguinte apar√™ncia:

O conte√∫do da pasta &quot;Tempo de leitura&quot;: manifest.json, content.js na pasta de scripts e imagens.

Carregar a extens√£o localmente
Para carregar uma extens√£o descompactada no modo de desenvolvedor, siga as etapas em No√ß√µes b√°sicas de desenvolvimento.

Abrir a documenta√ß√£o de uma extens√£o ou da Chrome Web Store
Confira algumas p√°ginas que voc√™ pode abrir para saber quanto tempo cada artigo vai levar para ser lido.

Publicar na Chrome Web Store
Como entender os scripts de conte√∫do
Ele ser√° parecido com o seguinte:

Tempo de leitura na p√°gina de boas-vindas
P√°gina de boas-vindas da extens√£o com a extens√£o Reading Time
üéØ Poss√≠veis melhorias
Com base no que voc√™ aprendeu hoje, tente implementar uma das seguintes op√ß√µes:

Adicione outro padr√£o de correspond√™ncia no arquivo manifest.json para oferecer suporte a outras p√°ginas do desenvolvedor do Chrome, como, por exemplo, o Chrome DevTools ou o Workbox.
Adicione um novo script de conte√∫do que calcula o tempo de leitura em qualquer um dos seus blogs ou sites de documenta√ß√£o favoritos.
Dica: voc√™ pode usar as DevTools para inspecionar elementos DOM.
Continuar criando
Parab√©ns por concluir este tutorial üéâ. Continue desenvolvendo suas habilidades concluindo outros tutoriais desta s√©rie:

Extens√£o	O que voc√™ vai aprender
Modo sem distra√ß√µes	Para executar o c√≥digo na p√°gina atual depois de clicar na a√ß√£o de extens√£o.
Gerenciador de guias	Para criar um pop-up que gerencie as guias do navegador.
Continue descobrindo
Esperamos que voc√™ tenha gostado de criar essa extens√£o do Chrome e que continue sua jornada de aprendizado de desenvolvimento do Chrome. Recomendamos o seguinte caminho de aprendizagem:

O guia para desenvolvedores tem dezenas de links adicionais para partes da documenta√ß√£o relevantes √† cria√ß√£o de extens√µes avan√ßadas.
As extens√µes t√™m acesso a APIs poderosas al√©m do que est√° dispon√≠vel na Web aberta. A documenta√ß√£o das APIs do Chrome explica cada uma delas.

P√°gina inicial
Docs
Chrome Extensions
Get started
Isso foi √∫til?

Injete scripts na guia ativa

bookmark_border
Simplifique o estilo da p√°gina atual clicando no √≠cone da barra de ferramentas da extens√£o.

Vis√£o geral
Este tutorial cria uma extens√£o que simplifica o estilo da extens√£o do Chrome e das p√°ginas de documenta√ß√£o da Chrome Web Store para que elas sejam mais f√°ceis de ler.

Neste guia, vamos explicar como fazer o seguinte:

Use o worker de servi√ßo de extens√£o como o coordenador de eventos.
Preserve a privacidade do usu√°rio com a permiss√£o "activeTab".
Executa o c√≥digo quando o usu√°rio clica no √≠cone da barra de ferramentas da extens√£o.
Insira e remova uma folha de estilo usando a API Scripting.
Use um atalho de teclado para executar o c√≥digo.
Antes de come√ßar
Neste guia, presumimos que voc√™ tenha experi√™ncia b√°sica em desenvolvimento da Web. Recomendamos conferir Hello World para uma introdu√ß√£o ao fluxo de trabalho de desenvolvimento de extens√µes.

Criar a extens√£o
Para come√ßar, crie um novo diret√≥rio chamado focus-mode que vai conter os arquivos da extens√£o. Se preferir, fa√ßa o download do c√≥digo-fonte completo no GitHub.

Etapa 1: adicionar os dados e √≠cones da extens√£o
Crie um arquivo chamado manifest.json e inclua o c√≥digo abaixo.


{
  "manifest_version": 3,
  "name": "Focus Mode",
  "description": "Enable focus mode on Chrome's official Extensions and Chrome Web Store documentation.",
  "version": "1.0",
  "icons": {
    "16": "images/icon-16.png",
    "32": "images/icon-32.png",
    "48": "images/icon-48.png",
    "128": "images/icon-128.png"
  }
}
Para saber mais sobre essas chaves, consulte o tutorial "Executar scripts em todas as guias", que explica os metadata e os √≠cones da extens√£o em mais detalhes.

Crie uma pasta images e fa√ßa o download dos √≠cones nela.

Etapa 2: inicializar a extens√£o
As extens√µes podem monitorar eventos do navegador em segundo plano usando o worker de servi√ßo da extens√£o. Os workers de servi√ßo s√£o ambientes JavaScript especiais que processam eventos e s√£o encerrados quando n√£o s√£o mais necess√°rios.

Comece registrando o service worker no arquivo manifest.json:


{
  ...
  "background": {
    "service_worker": "background.js"
  },
  ...
}
Crie um arquivo chamado background.js e adicione o seguinte c√≥digo:


chrome.runtime.onInstalled.addListener(() => {
  chrome.action.setBadgeText({
    text: "OFF",
  });
});
O primeiro evento que o worker de servi√ßo vai detectar √© runtime.onInstalled(). Esse m√©todo permite que a extens√£o defina um estado inicial ou conclua algumas tarefas na instala√ß√£o. As extens√µes podem usar a API Storage e o IndexedDB para armazenar o estado do aplicativo. No entanto, neste caso, como estamos lidando apenas com dois estados, vamos usar o texto do selo da a√ß√£o para rastrear se a extens√£o est√° "ATIVADA" ou "DESATIVADA".

Termo-chave:o selo da a√ß√£o √© um banner colorido na parte de cima da a√ß√£o de extens√£o (√≠cone da barra de ferramentas).
Etapa 3: ativar a a√ß√£o de extens√£o
A a√ß√£o da extens√£o controla o √≠cone da barra de ferramentas da extens√£o. Assim, sempre que o usu√°rio clicar no √≠cone da extens√£o, ele vai executar algum c√≥digo (como neste exemplo) ou mostrar um pop-up. Adicione o c√≥digo abaixo para declarar a a√ß√£o de extens√£o no arquivo manifest.json:


{
  ...
  "action": {
    "default_icon": {
      "16": "images/icon-16.png",
      "32": "images/icon-32.png",
      "48": "images/icon-48.png",
      "128": "images/icon-128.png"
    }
  },
  ...
}
Usar a permiss√£o activeTab para proteger a privacidade do usu√°rio
A permiss√£o activeTab concede √† extens√£o a capacidade tempor√°ria de executar c√≥digo na guia ativa. Ele tamb√©m permite o acesso a propriedades sens√≠veis da guia atual.

Essa permiss√£o √© ativada quando o usu√°rio invocar a extens√£o. Nesse caso, o usu√°rio invoca a extens√£o clicando na a√ß√£o de extens√£o.

üí° Quais outras intera√ß√µes do usu√°rio ativam a permiss√£o activeTab na minha extens√£o?

Pressionando uma combina√ß√£o de atalho do teclado.
Como selecionar um item do menu de contexto.
Aceitar uma sugest√£o da omnibox.
A abertura de um pop-up de extens√£o.
A permiss√£o "activeTab" permite que os usu√°rios escolham executar a extens√£o na guia focada. Dessa forma, a privacidade do usu√°rio √© protegida. Outro benef√≠cio √© que ele n√£o aciona um aviso de permiss√£o.

Para usar a permiss√£o "activeTab", adicione-a √† matriz de permiss√µes do manifesto:


{
  ...
  "permissions": ["activeTab"],
  ...
}
Etapa 4: acompanhar o estado da guia atual
Depois que o usu√°rio clicar na a√ß√£o da extens√£o, ela vai verificar se o URL corresponde a uma p√°gina de documenta√ß√£o. Em seguida, ele vai verificar o estado da guia atual e definir o pr√≥ximo estado. Adicione o seguinte c√≥digo a background.js:


const extensions = 'https://developer.chrome.com/docs/extensions';
const webstore = 'https://developer.chrome.com/docs/webstore';

chrome.action.onClicked.addListener(async (tab) => {
  if (tab.url.startsWith(extensions) || tab.url.startsWith(webstore)) {
    // Retrieve the action badge to check if the extension is 'ON' or 'OFF'
    const prevState = await chrome.action.getBadgeText({ tabId: tab.id });
    // Next state will always be the opposite
    const nextState = prevState === 'ON' ? 'OFF' : 'ON';

    // Set the action badge to the next state
    await chrome.action.setBadgeText({
      tabId: tab.id,
      text: nextState,
    });
  }
});
Etapa 5: adicionar ou remover a folha de estilo
Agora √© hora de mudar o layout da p√°gina. Crie um arquivo chamado focus-mode.css e inclua o seguinte c√≥digo:


* {
  display: none !important;
}

html,
body,
*:has(article),
article,
article * {
  display: revert !important;
}

[role='navigation'] {
  display: none !important;
}

article {
  margin: auto;
  max-width: 700px;
}
Insira ou remova a folha de estilo usando a API Scripting. Comece declarando a permiss√£o "scripting" no manifesto:


{
  ...
  "permissions": ["activeTab", "scripting"],
  ...
}
Sucesso:a API Scripting n√£o aciona um aviso de permiss√£o.
Por fim, em background.js, adicione o seguinte c√≥digo para mudar o layout da p√°gina:


  ...
    if (nextState === "ON") {
      // Insert the CSS file when the user turns the extension on
      await chrome.scripting.insertCSS({
        files: ["focus-mode.css"],
        target: { tabId: tab.id },
      });
    } else if (nextState === "OFF") {
      // Remove the CSS file when the user turns the extension off
      await chrome.scripting.removeCSS({
        files: ["focus-mode.css"],
        target: { tabId: tab.id },
      });
    }
  }
});
üí° Posso usar a API Scripting para injetar c√≥digo em vez de uma folha de estilo?

Sim. √â poss√≠vel usar scripting.executeScript() para injetar JavaScript.

Opcional: atribuir um atalho de teclado
S√≥ por divers√£o, adicione um atalho para facilitar a ativa√ß√£o ou desativa√ß√£o do modo de foco. Adicione a chave "commands" ao manifesto.


{
  ...
  "commands": {
    "_execute_action": {
      "suggested_key": {
        "default": "Ctrl+B",
        "mac": "Command+B"
      }
    }
  }
}
A chave "_execute_action" executa o mesmo c√≥digo do evento action.onClicked(). Portanto, nenhum c√≥digo adicional √© necess√°rio.

Testar se funciona
Verifique se a estrutura de arquivos do projeto tem a seguinte apar√™ncia:

O conte√∫do da pasta do modo de foco: manifest.json, background.js, focus-mode.css e a pasta de imagens.

Carregar a extens√£o localmente
Para carregar uma extens√£o descompactada no modo de desenvolvedor, siga as etapas em Hello World.

Testar a extens√£o em uma p√°gina de documenta√ß√£o
Primeiro, abra uma das seguintes p√°ginas:

Este √© o guia de documenta√ß√£o das extens√µes do Chrome
Publicar na Chrome Web Store
API Scripting
Em seguida, clique na a√ß√£o de extens√£o. Se voc√™ configurar um atalho de teclado, poder√° test√°-lo pressionando Ctrl + B ou Cmd + B.

A mudan√ßa deve ser esta:

Extens√£o do modo sem distra√ß√µes DESATIVADA
Extens√£o do Modo sem distra√ß√µes desativada
Para:

Extens√£o do Modo sem distra√ß√µes ATIVADA
Extens√£o do modo sem distra√ß√µes ativada
üéØ Poss√≠veis melhorias
Com base no que voc√™ aprendeu hoje, tente fazer o seguinte:

Melhore a folha de estilo CSS.
Atribuir um atalho diferente do teclado.
Mudar o layout do seu blog ou site de documenta√ß√£o favorito.
Continue desenvolvendo.
Parab√©ns por concluir este tutorial üéâ. Continue melhorando suas habilidades concluindo outros tutoriais desta s√©rie:

Extens√£o	O que voc√™ vai aprender
Tempo de leitura	Para inserir um elemento em um conjunto espec√≠fico de p√°ginas automaticamente.
Gerenciador de guias	Para criar um pop-up que gerencie as guias do navegador.
Continue descobrindo
Esperamos que voc√™ tenha gostado de criar essa extens√£o do Chrome e que continue sua jornada de aprendizado de desenvolvimento de extens√µes. Recomendamos os seguintes caminhos de aprendizagem:

O guia para desenvolvedores tem dezenas de links adicionais para partes da documenta√ß√£o relevantes √† cria√ß√£o de extens√µes avan√ßadas.
As extens√µes t√™m acesso a APIs poderosas al√©m do que est√° dispon√≠vel na Web aberta. A documenta√ß√£o das APIs do Chrome explica cada uma delas.
Isso foi √∫til?

Exceto em caso de indica√ß√£o contr√°ria, o conte√∫do desta p√°gina √© licenciado de acordo com a Licen√ßa de atribui√ß√£o 4.0 do Creative Commons, e as amostras de c√≥digo s√£o licenciadas de acordo com a Licen√ßa Apache 2.0. Para mais detalhes, consulte as pol√≠ticas do site do Google Developers. Java √© uma marca registrada da Oracle e/ou afiliadas.

√öltima atualiza√ß√£o 2022-10-04 UTC.

Processar eventos com service workers

bookmark_border
Tutorial que aborda conceitos de service worker de extens√£o

Vis√£o geral
Este tutorial apresenta os service workers de extens√µes do Chrome. Como parte deste tutorial, voc√™ vai criar uma extens√£o que permite aos usu√°rios navegar rapidamente at√© as p√°ginas de refer√™ncia da API Chrome usando a omnibox. Voc√™ aprender√° o seguinte:

Registre o service worker e importe m√≥dulos.
Depure o service worker da extens√£o.
Gerenciar estado e processar eventos.
Acionar eventos peri√≥dicos.
Comunicar com scripts de conte√∫do.
Antes de come√ßar
Neste guia, presumimos que voc√™ tenha experi√™ncia b√°sica em desenvolvimento da Web. Recomendamos que voc√™ leia No√ß√µes b√°sicas sobre extens√µes e Hello World para uma introdu√ß√£o ao desenvolvimento de extens√µes.

Criar a extens√£o
Comece criando um novo diret√≥rio chamado quick-api-reference para armazenar os arquivos de extens√£o ou fa√ßa o download do c√≥digo-fonte no reposit√≥rio de exemplos do GitHub.

Etapa 1: registrar o service worker
Crie o arquivo manifest na raiz do projeto e adicione o seguinte c√≥digo:

manifest.json:


{
  "manifest_version": 3,
  "name": "Open extension API reference",
  "version": "1.0.0",
  "icons": {
    "16": "images/icon-16.png",
    "128": "images/icon-128.png"
  },
  "background": {
    "service_worker": "service-worker.js"
  }
}
As extens√µes registram o service worker no manifesto, que usa apenas um arquivo JavaScript. N√£o √© necess√°rio chamar navigator.serviceWorker.register(), como faria em uma p√°gina da Web.

Crie uma pasta images e fa√ßa o download dos √≠cones nela.

Confira as primeiras etapas do tutorial "Tempo de leitura" para saber mais sobre os metadados e √≠cones da extens√£o no manifesto.

Etapa 2: importar v√°rios m√≥dulos de service worker
Nosso service worker implementa dois recursos. Para facilitar a manuten√ß√£o, vamos implementar cada recurso em um m√≥dulo separado. Primeiro, precisamos declarar o service worker como um m√≥dulo ES no manifesto, o que permite importar m√≥dulos no service worker:

manifest.json:


{
 "background": {
    "service_worker": "service-worker.js",
    "type": "module"
  },
}
Crie o arquivo service-worker.js e importe dois m√≥dulos:


import './sw-omnibox.js';
import './sw-tips.js';
Crie esses arquivos e adicione um registro do console a cada um deles.

sw-omnibox.js:


console.log("sw-omnibox.js");
sw-tips.js:


console.log("sw-tips.js");
Consulte Como importar scripts para saber mais sobre outras maneiras de importar v√°rios arquivos em um service worker.

Dica:n√£o se esque√ßa de definir "type.module" ao usar uma estrutura de agrupamento de m√≥dulos moderna, como o plug-in CRXjs Vite.
Opcional: depurar o service worker
Vou explicar como encontrar os registros do service worker e saber quando ele foi encerrado. Primeiro, siga as instru√ß√µes para carregar uma extens√£o descompactada.

Ap√≥s 30 segundos, voc√™ vai ver "service worker (inactive)", o que significa que o service worker foi encerrado. Clique no link "service worker (inactive)" para inspecionar. A anima√ß√£o a seguir mostra isso.

Voc√™ percebeu que inspecionar o service worker o ativou? Abrir o service worker nas devtools o mant√©m ativo. Para garantir que a extens√£o se comporte corretamente quando o service worker for encerrado, feche o DevTools.

Agora, divida a extens√£o para saber onde localizar erros. Uma maneira de fazer isso √© excluir ".js" da importa√ß√£o './sw-omnibox.js' no arquivo service-worker.js. O Chrome n√£o poder√° registrar o service worker.

Volte para chrome://extensions e atualize a extens√£o. Voc√™ vai encontrar dois erros:


Service worker registration failed. Status code: 3.

An unknown error occurred when fetching the script.
Consulte Depura√ß√£o de extens√µes para mais maneiras de depurar o service worker de extens√£o.

Cuidado:n√£o se esque√ßa de corrigir o nome do arquivo antes de continuar.
Etapa 4: inicializar o estado
O Chrome encerra os service workers se eles n√£o forem necess√°rios. Usamos a API chrome.storage para manter o estado nas sess√µes do service worker. Para acesso ao armazenamento, precisamos solicitar permiss√£o no manifesto:

manifest.json:


{
  ...
  "permissions": ["storage"],
}
Primeiro, salve as sugest√µes padr√£o no armazenamento. Podemos inicializar o estado quando a extens√£o √© instalada pela primeira vez detectando o evento runtime.onInstalled():

sw-omnibox.js:


...
// Save default API suggestions
chrome.runtime.onInstalled.addListener(({ reason }) => {
  if (reason === 'install') {
    chrome.storage.local.set({
      apiSuggestions: ['tabs', 'storage', 'scripting']
    });
  }
});
Os service workers n√£o t√™m acesso direto ao objeto window e, portanto, n√£o podem usar window.localStorage para armazenar valores. Al√©m disso, os service workers s√£o ambientes de execu√ß√£o de curta dura√ß√£o. Eles s√£o encerrados repetidamente durante a sess√£o do navegador de um usu√°rio, o que os torna incompat√≠veis com vari√°veis globais. Em vez disso, use chrome.storage.local, que armazena dados na m√°quina local.

Consulte Persistir dados em vez de usar vari√°veis globais para saber mais sobre outras op√ß√µes de armazenamento para service workers de extens√£o.

Etapa 5: registrar seus eventos
Todos os listeners de eventos precisam ser registrados de forma est√°tica no escopo global do service worker. Em outras palavras, os listeners de eventos n√£o podem ser aninhados em fun√ß√µes ass√≠ncronas. Assim, o Chrome pode garantir que todos os manipuladores de eventos sejam restaurados em caso de reinicializa√ß√£o de um service worker.

Neste exemplo, vamos usar a API chrome.omnibox, mas primeiro precisamos declarar o gatilho de palavra-chave da omnibox no manifesto:

manifest.json:


{
  ...
  "minimum_chrome_version": "102",
  "omnibox": {
    "keyword": "api"
  },
}
Ponto-chave:a refer√™ncia "minimum_chrome_version" explica como essa chave se comporta quando um usu√°rio tenta instalar sua extens√£o, mas n√£o est√° usando uma vers√£o compat√≠vel do Chrome.
Agora, registre os listeners de eventos da omnibox no n√≠vel superior do script. Quando o usu√°rio digita a palavra-chave da omnibox (api) na barra de endere√ßo seguida de tabula√ß√£o ou espa√ßo, o Chrome mostra uma lista de sugest√µes com base nas palavras-chave armazenadas. O evento onInputChanged(), que usa a entrada do usu√°rio atual e um objeto suggestResult, √© respons√°vel por preencher essas sugest√µes.

sw-omnibox.js:


...
const URL_CHROME_EXTENSIONS_DOC =
  'https://developer.chrome.com/docs/extensions/reference/';
const NUMBER_OF_PREVIOUS_SEARCHES = 4;

// Display the suggestions after user starts typing
chrome.omnibox.onInputChanged.addListener(async (input, suggest) => {
  await chrome.omnibox.setDefaultSuggestion({
    description: 'Enter a Chrome API or choose from past searches'
  });
  const { apiSuggestions } = await chrome.storage.local.get('apiSuggestions');
  const suggestions = apiSuggestions.map((api) => {
    return { content: api, description: `Open chrome.${api} API` };
  });
  suggest(suggestions);
});
Depois que o usu√°rio selecionar uma sugest√£o, o onInputEntered() vai abrir a p√°gina de refer√™ncia da API do Chrome correspondente.

sw-omnibox.js:


...
// Open the reference page of the chosen API
chrome.omnibox.onInputEntered.addListener((input) => {
  chrome.tabs.create({ url: URL_CHROME_EXTENSIONS_DOC + input });
  // Save the latest keyword
  updateHistory(input);
});
A fun√ß√£o updateHistory() recebe a entrada da omnibox e a salva em storage.local. Assim, o termo de pesquisa mais recente pode ser usado depois como uma sugest√£o da omnibox.

sw-omnibox.js:


...
async function updateHistory(input) {
  const { apiSuggestions } = await chrome.storage.local.get('apiSuggestions');
  apiSuggestions.unshift(input);
  apiSuggestions.splice(NUMBER_OF_PREVIOUS_SEARCHES);
  return chrome.storage.local.set({ apiSuggestions });
}
Ponto principal:os workers de servi√ßo de extens√£o podem usar APIs da Web e do Chrome, com algumas exce√ß√µes. Para mais informa√ß√µes, consulte Eventos do Service Worker.
Etapa 6: configurar um evento recorrente
Os m√©todos setTimeout() ou setInterval() s√£o usados com frequ√™ncia para realizar tarefas atrasadas ou peri√≥dicas. No entanto, essas APIs podem falhar porque o programador cancela os timers quando o service worker √© encerrado. Em vez disso, as extens√µes podem usar a API chrome.alarms.

Comece solicitando a permiss√£o "alarms" no manifesto:

manifest.json:


{
  ...
  "permissions": ["storage"],
  "permissions": ["storage", "alarms"],
}
A extens√£o vai buscar todas as dicas, escolher uma aleatoriamente e salvar no armazenamento. Vamos criar um alarme que ser√° acionado uma vez por dia para atualizar a dica. Os alarmes n√£o s√£o salvos quando voc√™ fecha o Chrome. Portanto, precisamos verificar se o alarme existe e cri√°-lo se n√£o existir.

Observa√ß√£o: o chrome.dev tem cabe√ßalhos CORS que permitem que sua extens√£o acesse a resposta. Se voc√™ precisar buscar conte√∫do de uma API sem cabe√ßalhos CORS, solicite permiss√µes de host para o host relevante.
sw-tips.js:


// Fetch tip & save in storage
const updateTip = async () => {
  const response = await fetch('https://chrome.dev/f/extension_tips/');
  const tips = await response.json();
  const randomIndex = Math.floor(Math.random() * tips.length);
  return chrome.storage.local.set({ tip: tips[randomIndex] });
};

const ALARM_NAME = 'tip';

// Check if alarm exists to avoid resetting the timer.
// The alarm might be removed when the browser session restarts.
async function createAlarm() {
  const alarm = await chrome.alarms.get(ALARM_NAME);
  if (typeof alarm === 'undefined') {
    chrome.alarms.create(ALARM_NAME, {
      delayInMinutes: 1,
      periodInMinutes: 1440
    });
    updateTip();
  }
}

createAlarm();

// Update tip once a day
chrome.alarms.onAlarm.addListener(updateTip);
Importante:todos os listeners de eventos e m√©todos da API Chrome reiniciam o timer de encerramento de 30 segundos do service worker. Para mais informa√ß√µes, consulte o ciclo de vida do service worker de extens√£o.
Etapa 7: comunicar-se com outros contextos
As extens√µes usam scripts de conte√∫do para ler e modificar o conte√∫do da p√°gina. Quando um usu√°rio visita uma p√°gina de refer√™ncia da API Chrome, o script de conte√∫do da extens√£o atualiza a p√°gina com a dica do dia. Ele envia uma mensagem para solicitar a dica do dia do service worker.

Comece declarando o script de conte√∫do no manifesto e adicione o padr√£o de correspond√™ncia correspondente √† documenta√ß√£o de refer√™ncia da API Chrome.

manifest.json:


{
  ...
  "content_scripts": [
    {
      "matches": ["https://developer.chrome.com/docs/extensions/reference/*"],
      "js": ["content.js"]
    }
  ]
}

Crie um arquivo de conte√∫do. O c√≥digo a seguir envia uma mensagem ao service worker solicitando a dica. Em seguida, adiciona um bot√£o que abre um popover com a dica da extens√£o. Esse c√≥digo usa a nova API Popover da plataforma da Web.

content.js:


(async () => {
  // Sends a message to the service worker and receives a tip in response
  const { tip } = await chrome.runtime.sendMessage({ greeting: 'tip' });

  const nav = document.querySelector('.upper-tabs > nav');
  
  const tipWidget = createDomElement(`
    <button type="button" popovertarget="tip-popover" popovertargetaction="show" style="padding: 0 12px; height: 36px;">
      <span style="display: block; font: var(--devsite-link-font,500 14px/20px var(--devsite-primary-font-family));">Tip</span>
    </button>
  `);

  const popover = createDomElement(
    `<div id='tip-popover' popover style="margin: auto;">${tip}</div>`
  );

  document.body.append(popover);
  nav.append(tipWidget);
})();

function createDomElement(html) {
  const dom = new DOMParser().parseFromString(html, 'text/html');
  return dom.body.firstElementChild;
}
A etapa final √© adicionar um gerenciador de mensagens ao service worker que envia uma resposta ao script de conte√∫do com a dica di√°ria.

sw-tips.js:


...
// Send tip to content script via messaging
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.greeting === 'tip') {
    chrome.storage.local.get('tip').then(sendResponse);
    return true;
  }
});
Testar se ele funciona
Verifique se a estrutura de arquivos do seu projeto √© semelhante a esta:

O conte√∫do da pasta de extens√£o: pasta &quot;images&quot;, manifest.json, service-worker.js, sw-omnibox.js, sw-tips.js e content.js

Carregar a extens√£o localmente
Para carregar uma extens√£o descompactada no modo de desenvolvedor, siga as etapas em Hello world.

Abrir uma p√°gina de refer√™ncia
Digite a palavra-chave "api" na barra de endere√ßo do navegador.
Pressione "tab" ou "espa√ßo".
Insira o nome completo da API.
OU escolha uma op√ß√£o na lista de pesquisas anteriores
Uma nova p√°gina ser√° aberta com a p√°gina de refer√™ncia da API Chrome.
Ele ser√° parecido com o seguinte:

Refer√™ncia r√°pida da API que abre a refer√™ncia da API de tempo de execu√ß√£o
Extens√£o r√°pida da API que abre a API Runtime.
Abrir a dica do dia
Clique no bot√£o "Dica" na barra de navega√ß√£o para abrir a dica da extens√£o.

Abrir dica di√°ria em 
Extens√£o r√°pida da API que abre a dica do dia.
Observa√ß√£o:a API Popover foi lan√ßada no Chrome 114.
üéØ Melhorias poss√≠veis
Com base no que voc√™ aprendeu hoje, tente fazer o seguinte:

Use outra maneira de implementar as sugest√µes da omnibox.
Crie seu pr√≥prio modal personalizado para mostrar a dica da extens√£o.
Abra outra p√°gina para as p√°ginas de refer√™ncia da API Web Extensions da MDN.
Continue criando!
Parab√©ns por concluir este tutorial üéâ. Continue aprimorando suas habilidades com outros tutoriais para iniciantes:

Extens√£o	O que voc√™ vai aprender
Tempo de leitura	Para inserir um elemento em um conjunto espec√≠fico de p√°ginas automaticamente.
Gerenciador de guias	Para criar um pop-up que gerencia guias do navegador.
Modo sem distra√ß√µes	Para executar o c√≥digo na p√°gina atual depois de clicar na a√ß√£o da extens√£o.
Continue descobrindo
Para continuar o programa de aprendizado sobre service workers de extens√£o, recomendamos que voc√™ leia os seguintes artigos:

Sobre os service workers de extens√£o.
O ciclo de vida do service worker da extens√£o.
Eventos em service workers
Isso foi √∫til?

Exceto em caso de indica√ß√£o contr√°ria, o conte√∫do desta p√°gina √© licenciado de acordo com a Licen√ßa de atribui√ß√£o 4.0 do Creative Commons, e as amostras de c√≥digo s√£o licenciadas de acordo com a Licen√ßa Apache 2.0. Para mais detalhes, consulte as pol√≠ticas do site do Google Developers. Java √© uma marca registrada da Oracle e/ou afiliadas.

√öltima atualiza√ß√£o 2023-04-02 UTC.

P√°gina inicial
Docs
Chrome Extensions
Get started
Isso foi √∫til?

Gerenciar guias

bookmark_border
Crie seu primeiro gerenciador de guias.

Vis√£o geral
Este tutorial cria um gerenciador de guias para organizar as guias da documenta√ß√£o da extens√£o e da Chrome Web Store.

Pop-up da extens√£o do Gerenciador de guias
Extens√£o do Gerenciador de guias
Neste guia, vamos explicar como fazer o seguinte:

Crie um pop-up de extens√£o usando a API Action.
Fa√ßa consultas para guias espec√≠ficas usando a API Tabs.
Preserve a privacidade do usu√°rio com permiss√µes restritas do host.
Mude o foco da guia.
Mova as guias para a mesma janela e agrupe-as.
Renomeie grupos de guias usando a API TabGroups.
Antes de come√ßar
Neste guia, presumimos que voc√™ tenha experi√™ncia b√°sica em desenvolvimento da Web. Recomendamos conferir Hello World para uma introdu√ß√£o ao fluxo de trabalho de desenvolvimento de extens√µes.

Criar a extens√£o
Para come√ßar, crie um novo diret√≥rio chamado tabs-manager para armazenar os arquivos da extens√£o. Se preferir, fa√ßa o download do c√≥digo-fonte completo no GitHub.

Etapa 1: adicionar os dados e √≠cones da extens√£o
Crie um arquivo chamado manifest.json e adicione o seguinte c√≥digo:


{
  "manifest_version": 3,
  "name": "Tab Manager for Chrome Dev Docs",
  "version": "1.0",
  "icons": {
    "16": "images/icon-16.png",
    "32": "images/icon-32.png",
    "48": "images/icon-48.png",
    "128": "images/icon-128.png"
  }
}
Para saber mais sobre essas chaves, confira o tutorial "Tempo de leitura", que explica os metadata e os √≠cones da extens√£o em mais detalhes.

Crie uma pasta images e fa√ßa o download dos √≠cones nela.

Etapa 2: criar e estilizar o pop-up
A API Action controla a a√ß√£o da extens√£o (√≠cone da barra de ferramentas). Quando o usu√°rio clica na a√ß√£o de extens√£o, ela executa um c√≥digo ou abre um pop-up, como neste caso. Comece declarando o pop-up no manifest.json:


{
  "action": {
    "default_popup": "popup.html"
  }
}
Um pop-up √© semelhante a uma p√°gina da Web, com uma exce√ß√£o: ele n√£o pode executar JavaScript inline. Crie um arquivo popup.html e adicione o seguinte c√≥digo:


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./popup.css" />
  </head>
  <body>
    <template id="li_template">
      <li>
        <a>
          <h3 class="title">Tab Title</h3>
          <p class="pathname">Tab Pathname</p>
        </a>
      </li>
    </template>

    <h1>Google Dev Docs</h1>
    <button>Group Tabs</button>
    <ul></ul>

    <script src="./popup.js" type="module"></script>
  </body>
</html>
Dica: √© poss√≠vel usar espera de n√≠vel superior adicionando type="module" √† tag de script.
Em seguida, voc√™ vai estilizar o pop-up. Crie um arquivo popup.css e adicione o seguinte c√≥digo:


body {
  width: 20rem;
}

ul {
  list-style-type: none;
  padding-inline-start: 0;
  margin: 1rem 0;
}

li {
  padding: 0.25rem;
}
li:nth-child(odd) {
  background: #80808030;
}
li:nth-child(even) {
  background: #ffffff;
}

h3,
p {
  margin: 0;
}
Etapa 3: gerenciar as guias
A API Tabs permite que uma extens√£o crie, consulte, modifique e reorganize guias no navegador.

Solicitar permiss√£o
Muitos m√©todos na API Tabs podem ser usados sem solicitar nenhuma permiss√£o. No entanto, precisamos ter acesso ao title e ao URL das guias. Essas propriedades sens√≠veis exigem permiss√£o. Poder√≠amos solicitar a permiss√£o "tabs", mas isso daria acesso √†s propriedades sens√≠veis de todas as guias. Como estamos gerenciando apenas as guias de um site espec√≠fico, vamos solicitar permiss√µes de host restritas.

As permiss√µes do host restritas nos permitem proteger a privacidade do usu√°rio concedendo permiss√µes elevadas a sites espec√≠ficos. Isso vai conceder acesso √†s propriedades title e URL, al√©m de recursos adicionais. Adicione o c√≥digo destacado ao arquivo manifest.json:


{
  "host_permissions": [
    "https://developer.chrome.com/*"
  ]
}
üí° Quais s√£o as principais diferen√ßas entre a permiss√£o de guias e as permiss√µes do host?

As permiss√µes "tabs" e do host t√™m desvantagens.

A permiss√£o "tabs" concede a uma extens√£o a capacidade de ler dados sens√≠veis em todas as guias. Com o tempo, essas informa√ß√µes podem ser usadas para coletar o hist√≥rico de navega√ß√£o de um usu√°rio. Portanto, se voc√™ solicitar essa permiss√£o, o Chrome vai mostrar a seguinte mensagem de aviso no momento da instala√ß√£o:

Caixa de di√°logo de aviso sobre permiss√µes das guias

As permiss√µes do host permitem que uma extens√£o leia e consulte as propriedades sens√≠veis de uma guia correspondente, al√©m de injetar scripts nessas guias. Os usu√°rios v√£o receber a seguinte mensagem de aviso no momento da instala√ß√£o:

Caixa de di√°logo de aviso de permiss√£o do host

Esse aviso pode ser alarmante para os usu√°rios. Para uma melhor experi√™ncia de integra√ß√£o, recomendamos implementar permiss√µes opcionais.

Consultar as guias
√â poss√≠vel recuperar as guias de URLs espec√≠ficos usando o m√©todo tabs.query(). Crie um arquivo popup.js e adicione o seguinte c√≥digo:


const tabs = await chrome.tabs.query({
  url: [
    "https://developer.chrome.com/docs/webstore/*",
    "https://developer.chrome.com/docs/extensions/*",
  ]
});
üí° Posso usar APIs do Chrome diretamente no pop-up?

Um pop-up e outras p√°ginas de extens√£o podem chamar qualquer API do Chrome porque s√£o veiculados no esquema do Chrome. Por exemplo, chrome-extension://EXTENSION_ID/popup.html.

Focar em uma guia
Primeiro, a extens√£o vai classificar os nomes das guias (os t√≠tulos das p√°ginas HTML contidas) em ordem alfab√©tica. Em seguida, quando um item da lista for clicado, ele vai se concentrar nessa guia usando tabs.update() e trazer a janela para a frente usando windows.update(). Adicione o seguinte c√≥digo ao arquivo popup.js:


...
const collator = new Intl.Collator();
tabs.sort((a, b) => collator.compare(a.title, b.title));

const template = document.getElementById("li_template");
const elements = new Set();
for (const tab of tabs) {
  const element = template.content.firstElementChild.cloneNode(true);

  const title = tab.title.split("-")[0].trim();
  const pathname = new URL(tab.url).pathname.slice("/docs".length);

  element.querySelector(".title").textContent = title;
  element.querySelector(".pathname").textContent = pathname;
  element.querySelector("a").addEventListener("click", async () => {
    // need to focus window as well as the active tab
    await chrome.tabs.update(tab.id, { active: true });
    await chrome.windows.update(tab.windowId, { focused: true });
  });

  elements.add(element);
}
document.querySelector("ul").append(...elements);
...
üí° JavaScript interessante usado neste c√≥digo

O Collator usado para classificar a matriz de guias pelo idioma preferido do usu√°rio.
A tag de modelo usada para definir um elemento HTML que pode ser clonado em vez de usar document.createElement() para criar cada item.
O construtor de URL usado para criar e analisar URLs.
A sintaxe de propaga√ß√£o usada para converter o conjunto de elementos em argumentos na chamada append().
Agrupar as guias
A API TabGroups permite que a extens√£o nomeie o grupo e escolha uma cor de plano de fundo. Adicione a permiss√£o "tabGroups" ao manifesto adicionando o c√≥digo destacado:


{
  "permissions": [
    "tabGroups"
  ]
}
Em popup.js, adicione o c√≥digo abaixo para criar um bot√£o que vai agrupar todas as guias usando tabs.group() e moviment√°-las para a janela atual.


const button = document.querySelector("button");
button.addEventListener("click", async () => {
  const tabIds = tabs.map(({ id }) => id);
  if (tabIds.length) {
    const group = await chrome.tabs.group({ tabIds });
    await chrome.tabGroups.update(group, { title: "DOCS" });
  }
});
Testar se funciona
Verifique se a estrutura de arquivos do projeto corresponde √† seguinte √°rvore de diret√≥rios:

O conte√∫do da pasta do gerenciador de guias: manifest.json, popup.js, popup.css, popup.html e a pasta de imagens.

Carregar a extens√£o localmente
Para carregar uma extens√£o descompactada no modo de desenvolvedor, siga as etapas em Hello World.

Abrir algumas p√°ginas de documenta√ß√£o
Abra os seguintes documentos em janelas diferentes:

Projetar a interface do usu√°rio
Descoberta na Chrome Web Store
Vis√£o geral do desenvolvimento de extens√µes
Formato do arquivo de manifesto
Publicar na Chrome Web Store
Clique no pop-up. Ele ser√° parecido com o seguinte:

Pop-up da extens√£o do Gerenciador de guias
Pop-up da extens√£o do Gerenciador de guias
Clique no bot√£o "Agrupar guias". Ele ser√° parecido com o seguinte:

Guias agrupadas do Gerenciador de guias
Guias agrupadas usando a extens√£o Gerenciador de guias
üéØ Poss√≠veis melhorias
Com base no que voc√™ aprendeu hoje, tente implementar uma das seguintes op√ß√µes:

Personalize a folha de estilo do pop-up.
Mude a cor e o t√≠tulo do grupo de guias.
Gerenciar as guias de outro site de documenta√ß√£o.
Adi√ß√£o de suporte para desfazer o agrupamento das guias agrupadas.
Continue desenvolvendo!
Parab√©ns por concluir este tutorial üéâ. Continue desenvolvendo suas habilidades concluindo outros tutoriais desta s√©rie:

Extens√£o	O que voc√™ vai aprender
Tempo de leitura	Para inserir um elemento em todas as p√°ginas automaticamente.
Modo sem distra√ß√µes	Para executar o c√≥digo na p√°gina atual depois de clicar na a√ß√£o da extens√£o.
Continue descobrindo
Esperamos que voc√™ tenha gostado de criar essa extens√£o do Chrome e que continue sua jornada de aprendizado de desenvolvimento do Chrome. Recomendamos o seguinte caminho de aprendizagem:

O guia para desenvolvedores
 tem dezenas de links adicionais para partes da documenta√ß√£o relevantes √† cria√ß√£o de extens√µes avan√ßadas.
As extens√µes t√™m acesso a APIs poderosas al√©m do que est√° dispon√≠vel na Web aberta. A documenta√ß√£o das APIs do Chrome explica cada uma delas.
Isso foi √∫til?

Exceto em caso de indica√ß√£o contr√°ria, o conte√∫do desta p√°gina √© licenciado de acordo com a Licen√ßa de atribui√ß√£o 4.0 do Creative Commons, e as amostras de c√≥digo s√£o licenciadas de acordo com a Licen√ßa Apache 2.0. Para mais detalhes, consulte as pol√≠ticas do site do Google Developers. Java √© uma marca registrada da Oracle e/ou afiliadas.

√öltima atualiza√ß√£o 2022-10-04 UTC.


