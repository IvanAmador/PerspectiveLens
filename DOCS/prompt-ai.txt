Home
Docs
AI on Chrome
Built-in
Was this helpful?

The Prompt API

bookmark_border

Thomas Steiner
Thomas Steiner
Alexandra Klepper
Alexandra Klepper

Published: May 20, 2025, Last updated: September 21, 2025

Explainer	Web	Extensions	Chrome Status	Intent
GitHub	Origin trial Origin trial	 Chrome 138	View	Intent to Experiment
With the Prompt API, you can send natural language requests to Gemini Nano in the browser.

There are many ways you can use the Prompt API. For example, you could build:

AI-powered search: Answer questions based on the content of a web page.
Personalized news feeds: Build a feed that dynamically classifies articles with categories and allow for users to filter for that content.
Custom content filters. Analyze news articles and automatically blur or hide content based on user-defined topics.
Calendar event creation. Develop a Chrome Extension that automatically extracts event details from web pages, so users can create calendar entries in just a few steps.
Seamless contact extraction. Build an extension that extracts contact information from websites, making it easier for users to contact a business or add details to their list of contacts.
These are just a few possibilities, and we're excited to see what you create.

Important: Gemini Nano is a generative AI model. Before you build with APIs that use Gemini Nano, you should review the People + AI Guidebook for best practices, methods, and examples for designing with AI.
Review the hardware requirements
The following requirements exist for developers and the users who operate features using these APIs in Chrome. Other browsers may have different operating requirements.

The Language Detector and Translator APIs work in Chrome on desktop. These APIs do not work on mobile devices. The Prompt API, Summarizer API, Writer API, Rewriter API, and Proofreader API work in Chrome when the following conditions are met:

Operating system: Windows 10 or 11; macOS 13+ (Ventura and onwards); Linux; or ChromeOS (from Platform 16389.0.0 and onwards) on Chromebook Plus devices. Chrome for Android, iOS, and ChromeOS on non-Chromebook Plus devices are not yet supported by the APIs which use Gemini Nano.
Storage: At least 22 GB of free space on the volume that contains your Chrome profile.
Built-in models should be significantly smaller. The exact size may vary slightly with updates.
GPU inference: Strictly more than 4 GB of VRAM.
CPU inference: 16 GB of RAM or more and 4 CPU cores or more.
Network: Unlimited data or an unmetered connection.
Key term: A metered connection is a data-limited internet connection. Wi-Fi and ethernet connections tend to be unmetered by default, while cellular connections are often metered.
Gemini Nano's exact size may vary as the browser updates the model. To determine the current size, visit chrome://on-device-internals.

Note: If the available storage space falls to less than 10 GB after the download, the model is removed from your device. The model redownloads once the requirements are met.
Use the Prompt API
The Prompt API uses the Gemini Nano model in Chrome. While the API is built into Chrome, the model is downloaded separately the first time an origin uses the API. Before you use this API, acknowledge Google's Generative AI Prohibited Uses Policy.

Note: Extensions Developers should remove the expired origin trial permissions: "permissions": ["aiLanguageModelOriginTrial"].
To determine if the model is ready to use, call LanguageModel.availability().


const availability = await LanguageModel.availability();
Caution: Always pass the same options to the availability() function that you use in prompt() or promptStreaming(). This is critical, as some models may not support certain modalities or languages.
Before the model can be downloaded, there must be a user interaction, such as a click, tap, or key press.

If the response was downloadable or downloading, the model and APIs are available but must be downloaded before you can use the features. The user must interact with the page (such as a click, tap, or key press) for a download to be permitted.

To download and instantiate the model, call the create() function.


const session = await LanguageModel.create({
  monitor(m) {
    m.addEventListener('downloadprogress', (e) => {
      console.log(`Downloaded ${e.loaded * 100}%`);
    });
  },
});
If the response to availability() was downloading, listen for download progress and inform the user, as the download may take time.

Model parameters
The params() function informs you of the language model's parameters. The object has the following fields:

defaultTopK: The default top-K value.
maxTopK: The maximum top-K value.
defaultTemperature: The default temperature.
maxTemperature: The maximum temperature.

await LanguageModel.params();
// {defaultTopK: 3, maxTopK: 128, defaultTemperature: 1, maxTemperature: 2}
Create a session
Once the Prompt API can run, you create a session with the create() function.

Each session can be customized with topK and temperature using an optional options object. The default values for these parameters are returned from LanguageModel.params().


const params = await LanguageModel.params();
// Initializing a new session must either specify both `topK` and
// `temperature` or neither of them.
const slightlyHighTemperatureSession = await LanguageModel.create({
  temperature: Math.max(params.defaultTemperature * 1.2, 2.0),
  topK: params.defaultTopK,
});
The create() function's optional options object also takes a signal field, which lets you pass an AbortSignal to destroy the session.


const controller = new AbortController();
stopButton.onclick = () => controller.abort();

const session = await LanguageModel.create({
  signal: controller.signal,
});
Add context with initial prompts
With initial prompts, you can provide the language model with context about previous interactions, for example, to allow the user to resume a stored session after a browser restart.


const session = await LanguageModel.create({
  initialPrompts: [
    { role: 'system', content: 'You are a helpful and friendly assistant.' },
    { role: 'user', content: 'What is the capital of Italy?' },
    { role: 'assistant', content: 'The capital of Italy is Rome.' },
    { role: 'user', content: 'What language is spoken there?' },
    {
      role: 'assistant',
      content: 'The official language of Italy is Italian. [...]',
    },
  ],
});
Constrain responses with a prefix
You can add an "assistant" role, in addition to previous roles, to elaborate on the model's previous responses. For example:


const followup = await session.prompt([
  {
    role: "user",
    content: "I'm nervous about my presentation tomorrow"
  },
  {
    role: "assistant",
    content: "Presentations are tough!"
  }
]);
In some cases, instead of requesting a new response, you may want to prefill part of the "assistant"-role response message. This can be helpful to guide the language model to use a specific response format. To do this, add prefix: true to the trailing "assistant"-role message. For example:


const characterSheet = await session.prompt([
  {
    role: 'user',
    content: 'Create a TOML character sheet for a gnome barbarian',
  },
  {
    role: 'assistant',
    content: '```toml\n',
    prefix: true,
  },
]);
Add expected input and output
The Prompt API has multimodal capabilities and supports multiple languages. Set the expectedInputs and expectedOutputs modalities and languages when creating your session.

type: Modality expected.
For expectedInputs, this can be text, image, or audio.
For expectedOutputs, the Prompt API allows text only.
languages: Array to set the language or languages expected. The Prompt API accepts "en", "ja", and "es". Support for additional languages is in development.
For expectedInputs, set the system prompt language and one or more expected user prompt languages.
Set one or more expectedOutputs languages.

const session = await LanguageModel.create({
  expectedInputs: [
    { type: "text", languages: ["en" /* system prompt */, "ja" /* user prompt */] }
  ],
  expectedOutputs: [
    { type: "text", languages: ["ja"] }
  ]
});
You may receive a "NotSupportedError" DOMException if the model encounters an unsupported input or output.

Multimodal capabilities
Caution: Multimodal capabilities are in the Prompt API origin trial for web and Chrome Extensions. These are not yet available in Chrome Stable.
With these capabilities, you could:

Allow users to transcribe audio messages sent in a chat application.
Describe an image uploaded to your website for use in a caption or alt text.
Take a look at the Mediarecorder Audio Prompt demo for using the Prompt API with audio input and the Canvas Image Prompt demo for using the Prompt API with image input.

Append messages
Inference may take some time, especially when prompting with multimodal inputs. It can be useful to send predetermined prompts in advance to populate the session, so the model can get a head start on processing.

While initialPrompts are useful at session creation, the append() method can be used in addition to the prompt() or promptStreaming() methods, to give additional additional contextual prompts after the session is created.

For example:


const session = await LanguageModel.create({
  initialPrompts: [
    {
      role: 'system',
      content:
        'You are a skilled analyst who correlates patterns across multiple images.',
    },
  ],
  expectedInputs: [{ type: 'image' }],
});

fileUpload.onchange = async () => {
  await session.append([
    {
      role: 'user',
      content: [
        {
          type: 'text',
          value: `Here's one image. Notes: ${fileNotesInput.value}`,
        },
        { type: 'image', value: fileUpload.files[0] },
      ],
    },
  ]);
};

analyzeButton.onclick = async (e) => {
  analysisResult.textContent = await session.prompt(userQuestionInput.value);
};
The promise returned by append() fulfills once the prompt has been validated, processed, and appended to the session. The promise is rejected if the prompt cannot be appended.

Pass a JSON Schema
Add the responseConstraint field to prompt() or promptStreaming() method to pass a JSON Schema as the value. You can then use structured output with the Prompt API.

In the following example, the JSON Schema makes sure the model responds with true or false to classify if a given message is about pottery.


const session = await LanguageModel.create();

const schema = {
  "type": "boolean"
};

const post = "Mugs and ramen bowls, both a bit smaller than intended, but that
happens with reclaim. Glaze crawled the first time around, but pretty happy
with it after refiring.";

const result = await session.prompt(
  `Is this post about pottery?\n\n${post}`,
  {
    responseConstraint: schema,
  }
);
console.log(JSON.parse(result));
// true
Your implementation can include a JSON Schema or regular expression as part of the message sent to the model. This uses some of the input quota. You can measure how much of the input quota it will use by passing the responseConstraint option to session.measureInputUsage().

You can avoid this behavior with the omitResponseConstraintInput option. If you do so, we recommend that you include some guidance in the prompt:


const result = await session.prompt(`
  Summarize this feedback into a rating between 0-5. Only output a JSON
  object { rating }, with a single property whose value is a number:
  The food was delicious, service was excellent, will recommend.
`, { responseConstraint: schema, omitResponseConstraintInput: true });
Prompt the model
You can prompt the model with either the prompt() or the promptStreaming() functions.

Non-streamed output
If you expect a short result, you can use the prompt() function that returns the response once it's available.


// Start by checking if it's possible to create a session based on the
// availability of the model, and the characteristics of the device.
const { defaultTemperature, maxTemperature, defaultTopK, maxTopK } =
  await LanguageModel.params();

const available = await LanguageModel.availability();

if (available !== 'unavailable') {
  const session = await LanguageModel.create();

  // Prompt the model and wait for the whole result to come back.
  const result = await session.prompt('Write me a poem!');
  console.log(result);
}
Streamed output
If you expect a longer response, you should use the promptStreaming() function which lets you show partial results as they come in from the model. The promptStreaming() function returns a ReadableStream.


const { defaultTemperature, maxTemperature, defaultTopK, maxTopK } =
  await LanguageModel.params();

const available = await LanguageModel.availability();
if (available !== 'unavailable') {
  const session = await LanguageModel.create();

  // Prompt the model and stream the result:
  const stream = session.promptStreaming('Write me an extra-long poem!');
  for await (const chunk of stream) {
    console.log(chunk);
  }
}
Stop prompting
Both prompt() and promptStreaming() accept an optional second parameter with a signal field, which lets you stop running prompts.


const controller = new AbortController();
stopButton.onclick = () => controller.abort();

const result = await session.prompt('Write me a poem!', {
  signal: controller.signal,
});
Session management
Each session keeps track of the context of the conversation. Previous interactions are taken into account for future interactions until the session's context window is full.

Each session has a maximum number of tokens it can process. Check your progress towards this limit with the following:


console.log(`${session.inputUsage}/${session.inputQuota}`);
Learn more about session management.

Clone a session
To preserve resources, you can clone an existing session with the clone() function. The conversation context is reset, but the initial prompt remains intact. The clone() function takes an optional options object with a signal field, which lets you pass an AbortSignal to destroy the cloned session.


const controller = new AbortController();
stopButton.onclick = () => controller.abort();

const clonedSession = await session.clone({
  signal: controller.signal,
});
Terminate a session
Call destroy() to free resources if you no longer need a session. When a session is destroyed, it can no longer be used, and any ongoing execution is aborted. You may want to keep the session around if you intend to prompt the model often since creating a session can take some time.


await session.prompt(
  "You are a friendly, helpful assistant specialized in clothing choices."
);

session.destroy();

// The promise is rejected with an error explaining that
// the session is destroyed.
await session.prompt(
  "What should I wear today? It is sunny, and I am choosing between a t-shirt
  and a polo."
);
Demos
We've built multiple demos to explore the many use cases for the Prompt API. The following demos are web applications:

Prompt API playground
Mediarecorder Audio Prompt
Canvas Image Prompt
To test the Prompt API in Chrome Extensions, install the demo extension. The extension source code is available on GitHub.

Performance strategy
The Prompt API for the web is still being developed. While we build this API, refer to our best practices on session management for optimal performance.

Permission Policy, iframes, and Web Workers
By default, the Prompt API is only available to top-level windows and to their same-origin iframes. Access to the API can be delegated to cross-origin iframes using the Permission Policy allow="" attribute:


<!--
  The hosting site at https://main.example.com can grant a cross-origin iframe
  at https://cross-origin.example.com/ access to the Prompt API by
  setting the `allow="language-model"` attribute.
-->
<iframe src="https://cross-origin.example.com/" allow="language-model"></iframe>
The Prompt API isn't available in Web Workers for now, due to the complexity of establishing a responsible document for each worker in order to check the permissions policy status.

Participate and share feedback
Your input can directly impact how we build and implement future versions of this API and all built-in AI APIs.

For feedback on Chrome's implementation, file a bug report or a feature request.
Share your feedback on the API shape by commenting on an existing Issue or by opening a new one in the Prompt API GitHub repository.
Join the early preview program.
Was this helpful?

Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.

Last updated 2025-09-21 UTC.

Best practices for session management with the Prompt API

bookmark_border

Thomas Steiner
Thomas Steiner

Published: January 27, 2025

Explainer	Web	Extensions	Chrome Status	Intent
GitHub	Origin trial Origin trial	 Chrome 138	View	Intent to Experiment
One key feature of the Prompt API is sessions. They let you have one or multiple ongoing conversations with the AI model, without the model losing track of the context of what was said. This guide introduces best practices for session management with the language model.

You may want to engage in session management for one or more parallel sessions if you're building a classic chatbot, where one user interacts with AI. Or, if you have a customer relationship management systems where one support agent deals with multiple customers in parallel and makes use of AI to help the support agent keep track of the various conversations.

Initialize sessions with an initial prompt
An initial prompt sets up the context of the session at the start. For example, you can use the initial prompt to tell the model how it should respond.


const languageModel = await LanguageModel.create({
  initialPrompts: [{
    role: 'system',
    content: 'You are a helpful assistant and you speak like a pirate.'
  }],
});
console.log(await languageModel.prompt('Tell me a joke.'));
// 'Avast ye, matey! What do you call a lazy pirate?\n\nA **sail-bum!**\n\nAhoy
// there, me hearties!  Want to hear another one? \n'
Clone a main session
If you want to start a new session after a session ends, or if you want to have multiple independent conversations in parallel, you can clone a main session.

The clone inherits session parameters, such as temperature or topK, and any session interaction history. This is useful if, for example, you initialized the main session with a initial prompt. This way, your app only needs to do this work once—all clones inherit the initial prompt from the main session.


const languageModel = await LanguageModel.create({
  initialPrompts: [{
    role: 'system',
    content: 'You are a helpful assistant and you speak like a pirate.'
  }]
});

// The original session `languageModel` remains unchanged, and
// the two clones can be interacted with independently from each other.
const firstClonedLanguageModel = await languageModel.clone();
const secondClonedLanguageModel = await languageModel.clone();
// Interact with the sessions independently.
await firstClonedLanguageModel.prompt('Tell me a joke about parrots.');
await secondClonedLanguageModel.prompt('Tell me a joke about treasure troves.');
// Each session keeps its own context.
// The first session's context is jokes about parrots.
await firstClonedLanguageModel.prompt('Tell me another.');
// The second session's context is jokes about treasure troves.
await secondClonedLanguageModel.prompt('Tell me another.');
Restore a past session
With initial prompts, you can prime the model with a set of example prompts and responses, to generate better results. This is often used in n-shot prompting, to create responses that mirror your expectations.

Note: There's a feature request to restore sessions, but until then, this creative usage of initial prompts works.
If you keep track of ongoing conversations with the model, you can use this practice to restore a session. For example, after a browser restarts, you can help your user continue engaging with the model from where they left off. One approach is to keep track of session history in local storage.


// Restore the session from localStorage, or initialize a new session.
// The UUID is hardcoded here, but would come from a
// session picker in your user interface.
const uuid = '7e62c0e0-6518-4658-bc38-e7a43217df87';

function getSessionData(uuid) {
  try {
    const storedSession = localStorage.getItem(uuid);
    return storedSession ? JSON.parse(storedSession) : false;
  } catch {
    return false;
  }
}

let sessionData = getSessionData(uuid);

// Initialize a new session.
if (!sessionData) {
  // Get the current default parameters so they can be restored as they were,
  // even if the default values change in the future.
  const { defaultTopK, defaultTemperature } =
    await LanguageModel.params();
  sessionData = {
    initialPrompts: [],
    topK: defaultTopK,
    temperature: defaultTemperature,
  };
}

// Initialize the session with the (previously stored or new) session data.
const languageModel = await LanguageModel.create(sessionData);

// Keep track of the ongoing conversion and store it in localStorage.
const prompt = 'Tell me a joke';
try {
  const stream = languageModel.promptStreaming(prompt);
  let result = '';
  // You can already work with each `chunk`, but then store
  // the final `result` in history.
  for await (const chunk of stream) {
    // In practice, you'd render the chunk.
    console.log(chunk);
    result = chunk;
  }

  sessionData.initialPrompts.push(
    { role: 'user', content: prompt },
    { role: 'assistant', content: result },
  );

  // To avoid growing localStorage infinitely, make sure to delete
  // no longer used sessions from time to time.
  localStorage.setItem(uuid, JSON.stringify(sessionData));
} catch (err) {
  console.error(err.name, err.message);
}
Tip: Use the Summarizer API initialized with a type: 'headline' options field to automatically give each session a human-readable session title.
Preserve session quota by letting the user stop the model
Each session has a context window that you can see by accessing the session's relevant fields inputQuota and inputUsage.


const { inputQuota, inputUsage } = languageModel;
const inputQuotaLeft = inputQuota - inputUsage;
When this context window is exceeded, it causes the session to lose track of the oldest messages. This may lead to worse results if the context was important. To preserve quota, if a user determines the model's answer isn't useful, allow them to stop the session with AbortController.

Both the prompt() and the promptStreaming() methods accept an optional second parameter with a signal field, to allow the user to stop the session.


const controller = new AbortController();
stopButton.onclick = () => controller.abort();

try {
  const stream = languageModel.promptStreaming('Write me a poem!', {
    signal: controller.signal,
  });
  for await (const chunk of stream) {
    console.log(chunk);
  }
} catch (err) {
  // Ignore `AbortError` errors.
  if (err.name !== 'AbortError') {
    console.error(err.name, err.message);
  }
}
Remove unused sessions
Each session consumes memory. If you have started several large sessions, this may become a problem. Delete unused sessions to raise resource availability.

Note: The model is unloaded after a period of time if there are no living sessions. Thus, you likely want to keep one empty session alive at a time, as it uses limited memory and keeps the model ready to use. Empty sessions should be removed and replaced as other sessions are created, so resources are available for their full potential.
Demo
See AI session management in action in the AI session management demo. Create multiple parallel conversations with the Prompt API, reload the tab or even restart your browser, and continue where you left off. See the source code on GitHub.


Unlock the full potential of the Prompt API
By thoughtfully managing AI sessions with these techniques and best practices, you can unlock the full potential of the Prompt API, delivering more efficient, responsive, and user-centric applications. You can also combine these approaches, for example, by letting the user clone a restored past session, so they can run "what if" scenarios.

Structured output support for the Prompt API

bookmark_border

Thomas Steiner
Thomas Steiner

Published: May 13, 2025

Large language models (LLMs) are notorious for their occasional lengthy responses. Even if you tell the model to answer with just "true" or "false," the model may respond with a friendly output and more than you asked for, such as: "Certainly, the answer is: true."

To address this challenge, the Prompt API lets you specify a JSON output format of the model's response by passing a JSON Schema to the LanguageModel.prompt() and LanguageModel.promptStreaming() methods. Structured output support is available as of Chrome version 137.

Important: Gemini Nano is a generative AI model. Before you build with APIs that use Gemini Nano, you should review the People + AI Guidebook for best practices, methods, and examples for designing with AI.
What is JSON Schema
JSON Schema is a vocabulary that enables JSON data consistency, validity, and interoperability at scale. When it comes to data exchange, JSON Schema stands out as a powerful standard for defining the structure and rules of JSON data. It uses a set of keywords to define the properties of your data.

JSON Schema is the industry standard for ensuring structured output, used, among others, by the OpenAI API and Gemini API.

For example, you prompt the model to assign at most three hashtags for a post on an online social network, such as Mastodon. The ideal output could look similar to the following JSON:


{
  "hashtags": [
    "#pottery",
    "#dyi"
  ] 
}
The corresponding JSON Schema for this requested output object shape would then look as follows:


{
  "type": "object",
  "properties": {
    "hashtags": {
      "type": "array",
      "maxItems": 3,
      "items": {
        "type": "string",
        "pattern": "^#[^\\s#]+$"
      }
    }
  },
  "required": ["hashtags"],
  "additionalProperties": false
}
This JSON Schema defines a structure for an object that must contain a hashtags field with the following constraints:

"type": "object": The root value must be a JSON object.
"properties": { "hashtags": ... }: The object can (and in this case, must) have a property called hashtags.
"hashtags":

"type": "array": The value must be an array.
"maxItems": 3: The array can contain at most 3 items.
"items": { "type": "string", "pattern": "^#[^\\s#]+$" }: Each item in the array must be a string that matches the given regular expression pattern: ^#[^\\s#]+$:
^# → must start with a #.
[^\\s#]+ → followed by one or more characters that are not a space (\s) or another #.
$ → must end there.
"required": ["hashtags"]: The object must contain the hashtags property.

"additionalProperties": false: No other properties than hashtags are allowed.

Read the JSON Schema Basics documentation for a complete description of the format's capabilities.

In fact, LLMs are really good at creating JSON Schema. Describe the constraints in natural language in your prompt and provide a valid example JSON object, and you're halfway there. You can then validate JSON objects against the generated JSON Schema with one of the JSON Schema validators, for example, the online Newtonsoft JSON Schema Validator.

Successfully validating a JSON object against a JSON Schema in a JSON
Schema validator.

Pass a JSON Schema to the Prompt API
To make sure the model respects a requested JSON Schema, you need to pass the JSON Schema as an argument to the prompt() or the promptStreaming() methods' options object as the value of a responseConstraint field.

Here's a very basic JSON Schema example that makes sure the model responds with either true or false in classifying whether a given message like this Mastodon post is about pottery.


const session = await LanguageModel.create();

const schema = {
  "type": "boolean"
};

const post = "Mugs and ramen bowls, both a bit smaller than intended- but that's
how it goes with reclaim. Glaze crawled the first time around, but pretty happy
with it after refiring.";

const result = await session.prompt(  
  `Is this post about pottery?\n\n${post}`,
  {  
    responseConstraint: schema,
  }
);
console.log(JSON.parse(result));
// true
Support predictable outputs
Structured output support for the Prompt API makes the responses of the LLM a lot more predictable. Rather than extracting an object from a Markdown response or other post-processing, developers can now assume the model's response is valid JSON.

This brings built-in AI one step closer to cloud-based APIs, with all the benefits of running local, client-side AI.